<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">
    <title>000HelloWorld</title>
    <link rel="stylesheet" href="css/animate.css">
    <style></style>
    <script src="bower_components/vue/dist/vue.js"></script>
</head>
<body>
<div id="app">
    <my-component></my-component>
</div>
<script>
    //我们可以用 Vue.extend() 创建一个组件构造器：
    var MyComponent = Vue.extend({
        template: "<div>custom component!</div>"
    })

    //要把这个构造器用作组件，需要用 Vue.component(tag, constructor) 注册

    //对于自定义标签名字，Vue.js 不强制要求遵循 W3C 规则（小写，并且包含一个短杠）
    // ，尽管遵循这个规则比较好
    Vue.component("my-component", MyComponent)

    //注意组件的模板替换了自定义元素，自定义元素的作用只是作为一个挂载点。
    // 这可以用实例选项 replace 改变

    var vm = new Vue({
        el: "#app"
    })
</script>

<div id="app2">
    <my-child-compo></my-child-compo>
</div>
<script>
    var Child = Vue.extend({
        template: "<span>child component 无需注册</span>"
    })
    var Parent = Vue.extend({
        components: {
            "my-child-compo": Child
        }
    })
    var vm = new Parent({
        el: "#app2"
    })
</script>

<!--
传入 Vue 构造器的多数选项也可以用在 Vue.extend() 中，
不过有两个特例： data and el。试想如果我们简单地把一个对象作为 data 选项传给 Vue.extend()
这么做的问题是 MyComponent 所有的实例将共享同一个 data 对象！
这基本不是我们想要的，因此我们应当使用一个函数作为 data 选项，函数返回一个新对象：
-->
<!--
var MyComponent = Vue.extend({
  data: function () {
    return { a: 1 }
  }
})
-->

<!--
Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相对于字符串模板这有一些好处，
但是也有问题。DOM 模板必须是有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制：

a 不能包含其它的交互元素（如按钮，链接）
ul 和 ol 只能直接包含 li
select 只能包含 option 和 optgroup
table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup
tr 只能直接包含 th 和 td
在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果。
例如 <my-select><option>...</option></my-select> 不是有效的模板，即使 my-select 组件最终展开为 <select>...</select>。

另一个结果是，自定义标签（包括自定义元素和特殊标签，如 <component>、<template>、 <partial> ）
不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面，因而渲染不正确。

对于自定义元素，应当使用 is 特性：

<table>
  <tr is="my-component"></tr>
</table>
<template> 不能用在 <table> 内，这时应使用 <tbody>，<table> 可以有多个 <tbody>：

<table>
  <tbody v-for="item in items">
    <tr>Even row</tr>
    <tr>Odd row</tr>
  </tbody>
</table>
-->
</body>
</html>

